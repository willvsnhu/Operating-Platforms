# Operating-Platforms

**Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?**

The client, The Gaming Room, wanted to expand their existing Android game Draw It or Lose It into a web-based application that could run on multiple platforms. Their requirements included unique game and team names, support for multiple players and teams, and ensuring only one instance of the game exists in memory.

**What did you do particularly well in developing this documentation?**

I clearly explained the design constraints and showed how object-oriented principles and patterns like Singleton and Iterator addressed the client’s needs.

**What about the process of working through a design document did you find helpful when developing the code?**

Creating the design document first gave me a roadmap. It helped me understand how the classes should relate, what patterns to use, and how to enforce the requirements before I started coding.

**If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?**

I would refine the evaluation section to provide more depth on the advantages and disadvantages of each operating platform. This would make my recommendations stronger and more detailed.

**How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?**

I translated the client’s needs, like uniqueness of names, multiple teams/players, and single-instance enforcement, directly into design patterns and class structure. Considering user needs is crucial because it ensures the final product solves the actual problem and delivers a functional, usable system.

**How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?**

I started with the UML diagram and requirements, then mapped them to object-oriented principles and design patterns. In the future, I would continue using this approach along with iterative testing and user feedback to refine the design early in the process.
